/* The BNF for this parser was derived from: http://savage.net.au/SQL/sql-92.bnf (SQL-92) 
* https://javacc.java.net/doc/docindex.html
* To debug changes to this file run:
* mvn clean generate-sources
*/
options{
STATIC = false;
}
/* *** Specification of the parser class *** */
PARSER_BEGIN(TableQueryParser)
package org.sagebionetworks.table.query;
import java.io.StringReader;
import java.util.LinkedList;
import java.util.List;

import org.sagebionetworks.table.query.model.*;

public class TableQueryParser {

	public TableQueryParser(String input){
		this(new StringReader(input));
	}

	/**
	 * Parse the passed query string into a TableQueryModel
	 * 
	 * @param query
	 * @return
	 * @throws ParseException
	 */
	public static QuerySpecification parserQuery(String query)
			throws ParseException {
		TableQueryParser parser = new TableQueryParser(new StringReader(query));
		return parser.Start();
	}
}

PARSER_END(TableQueryParser)

/**
* When in the DEFAULT state, double quotes are the start of
* string containing non-double quotes. This involves a state
* change to: within_double_quote.  The state change is necessary
* to limit the scope of the <not_double_quote> token which is too broad
* for other cases.
*/
<DEFAULT> TOKEN: 
{
	< start_double_quote: "\""> : within_double_quote
}
// This token only has meaning within a double quote.
<within_double_quote> TOKEN :
{
	< not_double_quote: ~["\""]> : within_double_quote
}
// This token only has meaning within a double quote.
<within_double_quote> TOKEN :
{
	< escape_double_quote: "\"\"" > : within_double_quote
}
/**
* While within a double quote string, another double
* quote will terminate the string and restore the state
* to DEFAULT.
*/
<within_double_quote> TOKEN :
{
	< end_double_quote: "\"">: DEFAULT
}


/**
* When in the DEFAULT state, single quotes are the start of
* string containing non-quotes. This involves a state
* change to: within_single_quotes.  The state change is necessary
* to limit the scope of the <not_quote> token which is too broad
* for other cases.
*/
<DEFAULT> TOKEN: 
{
	< start_single_quote: "'"> : within_single_quotes
}
// This token only has meaning within single quotes.
<within_single_quotes> TOKEN :
{
	< not_single_quote: ~["'"]> : within_single_quotes
}
// This token only has meaning within single quotes.
<within_single_quotes> TOKEN :
{
	< escape_single_quote: "''" > : within_single_quotes
}
/**
* While within single quote string, another single
* quote will terminate the string and restore the state
* to DEFAULT.
*/
<within_single_quotes> TOKEN :
{
	< end_single_quote: "'" > : DEFAULT
}

/* Skip whitespace */
SKIP : /* WHITE SPACE */
{ 
  " "
| "\t"
| "\r"
| "\f"
| "\n"
| < LOW_SPECIAL_ASCII: (["\u0000"-"\u001f"]) >
| < HIGH_SPECIAL_ASCII: (["\u007f"-"\u00ff"]) >
}

TOKEN:{
 <exponent: (["0"-"9"])+["e","E"]("+"|"-")?(["0"-"9"])+>
| < count_asterisk: ("count"|"COUNT")"(*)" >
}

/* Reserved words */
TOKEN [IGNORE_CASE]: {
  < all: "ALL">
| < and: "AND">
| < as: "AS">
| < avg: "AVG">
| < between: "BETWEEN" >
| < date: "DATE" >
| < count: "COUNT">
| < current_date: "CURRENT_DATE">
| < current_time: "CURRENT_TIME">
| < distinct: "DISTINCT">
| < default_specification: "DEFAULT" > 
| < escape: "ESCAPE">
| < _false: "FALSE">
| < from: "FROM">
| < interval: "INTERVAL">
| < in: "IN">
| < is: "IS">
| < like: "LIKE" >
| < max: "MAX" >
| < min: "MIN" >
| < not: "NOT" >
| < null_specification: "NULL" >
| < or: "OR" >
| < overlaps: "OVERLAPS" >
| < select: "SELECT" >
| < sum: "SUM" >
| < syn: "SYN" >
| < time: "TIME" >
| < timestamp: "TIMESTAMP">
| < _true: "TRUE">
| < where: "WHERE">
| < unknown: "UNKNOWN">
}
/* Symbols and punctuation */
TOKEN:{
  < asterisk: "*">
| < comma: ",">
| < left_paren: "(">
| < minus_sign: "-">
| < not_equals_operator: "<>">
| < less_than_or_equals_operator: "<=">
| < greater_than_or_equals_operator: ">=">
| < less_than_operator: "<">
| < greater_than_operator: ">">
| < equals_operator: "=">
| < period: "." >
| < plus_sign: "+">
| < right_paren: ")">
| < solidus: "/">
| <underscore: "_">
}

TOKEN: {
  < digit: ["0"-"9"]>
| < letter: ["a"-"z","A"-"Z"]>
}

void regularIdentifier(StringBuilder builder):
{
	Token token = null;
}
{
	token = <letter> { builder.append(token.image); }
	(
		 token = <letter> { builder.append(token.image); }
		 | token = <digit> { builder.append(token.image); }
		 | token = <underscore> { builder.append(token.image); }
	)* 
}
/** Literal Numbers, Strings, Dates and Times */

void unsignedInteger(StringBuilder builder):
{
	Token token = null;
}
{
	token = <digit> { builder.append(token.image); }
	(
		token = <digit> { builder.append(token.image); } 
	)*
}
void sign(StringBuilder builder):
{}
{
	<plus_sign> { builder.append("+"); }
	| <minus_sign> { builder.append("-"); }
}
void signedInteger(StringBuilder builder):
{}
{
	[ sign(builder) ] unsignedInteger(builder) 
}
void period(StringBuilder builder):
{}
{
	<period> { builder.append("."); }
}
void exactNumericLiteral(StringBuilder builder):
{}
{
	( unsignedInteger(builder) period(builder) unsignedInteger(builder) )
	| (  period(builder) unsignedInteger(builder) )
}
void exponent(StringBuilder builder):
{
	Token token = null;
}
{
	token = <exponent> { builder.append(token.image); }
}
void approximateNumericLiteral(StringBuilder builder):
{}
{
	(  period(builder) exponent(builder) )
	| ( unsignedInteger(builder) period(builder) exponent(builder) )
}
void unsignedNumericLiteral(StringBuilder builder):
{}
{
	( unsignedInteger(builder) period(builder) ( unsignedInteger(builder) | exponent(builder) ) )
	| ( period(builder) ( unsignedInteger(builder) | exponent(builder) ) )
}
void signedNumericLiteral(StringBuilder builder):
{
}
{
	[ sign(builder) ] unsignedNumericLiteral(builder)
}
String literal():
{
	StringBuilder builder = new StringBuilder();
}
{
	signedNumericLiteral(builder) { return builder.toString(); }
	| generalLiteral(builder) { return builder.toString(); }
}
void generalLiteral(StringBuilder builder):
{}
{
	characterStringLiteral(builder)
}
void characterStringLiteral(StringBuilder builder):
{
	Token token;
}
{
	<start_single_quote>
	(
		token = <not_single_quote> { builder.append(token.image); }
		| <escape_single_quote>  { builder.append("'"); }
	)*
	<end_single_quote>
}
/* This is the entry point of the parser*/
QuerySpecification Start():
{ 
	QuerySpecification querySpecification = null;
}
{
	querySpecification = querySpecification()
	{ return querySpecification; }
}
ValueExpressionPrimary valueExpressionPrimary():
{
	UnsignedValueSpecification unsignedValueSpecification = null;
	ColumnReference columnReference = null;
	SetFunctionSpecification setFunctionSpecification = null;
}
{
	setFunctionSpecification = setFunctionSpecification() { return new ValueExpressionPrimary(setFunctionSpecification);}
	| columnReference = columnReference() { return new ValueExpressionPrimary(columnReference);}
	| unsignedValueSpecification = unsignedValueSpecification() { return new ValueExpressionPrimary(unsignedValueSpecification); }
}
UnsignedValueSpecification unsignedValueSpecification():
{
	UnsignedLiteral unsignedLiteral;
}
{
	unsignedLiteral = unsignedLiteral() { return new UnsignedValueSpecification(unsignedLiteral); }
}
UnsignedLiteral unsignedLiteral():
{ StringBuilder builder = new StringBuilder(); }
{
	unsignedNumericLiteral(builder) { return new UnsignedLiteral(builder.toString(), null); }
	| generalLiteral(builder) { return new UnsignedLiteral(null, builder.toString()); }
}
String identifier():
{
	String identifier = null;
}
{
	identifier = actualIdentifier()
	{ return identifier;}
}
String actualIdentifier():
{
	StringBuilder builder = new StringBuilder();
}
{
	regularIdentifier(builder) { return builder.toString(); }
	| delimitedIentifier(builder) { return builder.toString(); }
}
void delimitedIentifier(StringBuilder builder):
{ 
	Token token = null;
}
{
	<start_double_quote>
	( 
		token = <not_double_quote> { builder.append(token.image); }
		| <escape_double_quote> { builder.append("\""); }
	)*
	<end_double_quote>
}
ColumnReference columnReference():
{
	Qualifier qualifier = null;
	String columnName = null;
}
{
	[ LOOKAHEAD(2) qualifier = qualifier() <period> ] columnName = columnName()
	{ return new ColumnReference(qualifier, columnName); }
}
QuerySpecification querySpecification():
{
	SetQuantifier setQuantifier = null;
	SelectList selectList = null;
	TableExpression tableExpression = null;
}
{
	<select> [ setQuantifier = setQuantifier()] selectList = selectList() tableExpression = tableExpression()
	{ return new QuerySpecification(setQuantifier, selectList, tableExpression); }
}
SelectList selectList():
{
	List<DerivedColumn> derivedColumns = new LinkedList<DerivedColumn>();
	DerivedColumn derivedColumn = null;
}
{
	<asterisk> { return new SelectList("*", null); }
	| derivedColumn = selectSubList()  { derivedColumns.add(derivedColumn); }
	 (<comma> derivedColumn = selectSubList()  { derivedColumns.add(derivedColumn); })*
	 { return new SelectList(null, derivedColumns); }
}
DerivedColumn selectSubList():
{
	DerivedColumn derivedColumn = null;
}
{
	derivedColumn = derivedColumn()
	{ return derivedColumn; }
}
DerivedColumn derivedColumn():
{
	String asClause = null;
	ValueExpression valueExpression = null;
}
{
	valueExpression = valueExpression() [ asClause = asClause()]
	{ return new DerivedColumn(valueExpression, asClause);}
}
String asClause():
{
	String columnName = null;
}
{
	<as> columnName = columnName()
	{ return columnName; }
}
TableExpression tableExpression():
{
	FromClause fromClause = null;
	WhereClause whereClause = null;
}
{
	fromClause = fromClause() [ whereClause = whereClause() ]
	{ return new TableExpression(fromClause, whereClause); }
}
FromClause fromClause():
{
	TableReference tableReference = null;
}
{
	<from> tableReference = tableReference()
	{ return new FromClause(tableReference); }
}
TableReference tableReference():
{
	String tableName = null;
}
{
	tableName = tableName()
	{ return new TableReference(tableName); }
}
String columnName():
{
	String columnName = null;
}
{
	columnName = identifier() {return columnName; }
}
SetQuantifier setQuantifier():
{}
{
	<distinct> { return SetQuantifier.DISTINCT;}
	|<all> { return SetQuantifier.ALL;}
}
Qualifier qualifier():
{
	String colunName = null;
}
{
	tableName = columnName() { return new Qualifier(tableName, null); }
}
String tableName():
{ 
	StringBuilder builder = new StringBuilder();
}
{	
	[<syn>] unsignedInteger(builder) { return builder.toString(); }
}
SetFunctionSpecification setFunctionSpecification():
{ SetFunctionSpecification setFunction = null; }
{
	<count_asterisk>
	{ return new SetFunctionSpecification(Boolean.TRUE); }
	| setFunction = generalSetFunction() { return setFunction;}
}
SetFunctionSpecification generalSetFunction():
{ 
	SetFunctionType setFunctionType = null;
	SetQuantifier setQuantifier = null;
	ValueExpression valueExpression = null;
}
{
	setFunctionType = setFunctionType() <left_paren> [ setQuantifier = setQuantifier() ] valueExpression = valueExpression() <right_paren>
	{ return new SetFunctionSpecification(setFunctionType, setQuantifier, valueExpression);}
}
SetFunctionType setFunctionType():
{}
{
	<avg> { return SetFunctionType.AVG; }
	| <max> { return SetFunctionType.MAX; }
	| <min> { return SetFunctionType.MIN; }
	| <sum> { return SetFunctionType.SUM; }
	| <count> { return SetFunctionType.COUNT; }
}
WhereClause whereClause():
{
	SearchCondition searchCondition;
}
{
	<where> searchCondition = searchCondition() { return new WhereClause(searchCondition);}
}
/**
* The reference BNF definition for searchCondition() is "left recursive"
* which is not possible with javacc, so it was re-written.
*/
SearchCondition searchCondition():
{
	SearchCondition searchCondition = new SearchCondition();
	BooleanTerm lastBooleanTerm = null;
}
{
	lastBooleanTerm = booleanTerm() { searchCondition.addOrBooleanTerm(lastBooleanTerm); }
	( <or> lastBooleanTerm = booleanTerm() { searchCondition.addOrBooleanTerm(lastBooleanTerm); } )*
	{ return searchCondition; }
}
/**
* The reference BNF definition for booleanTerm() is "left recursive"
* which is not possible with javacc, so it was re-written. 
*/
BooleanTerm booleanTerm():
{
	BooleanTerm booleanTerm = new BooleanTerm();
	BooleanFactor booleanFactor = null;
}
{
	booleanFactor = booleanFactor() { booleanTerm.addAndBooleanFactor(booleanFactor); }
	( <and>  booleanFactor = booleanFactor() { booleanTerm.addAndBooleanFactor(booleanFactor); } )*
	{ return booleanTerm; }
}
BooleanFactor booleanFactor():
{
	Boolean notB = null;
	BooleanTest booleanTest = null;
}
{
	[ <not> { notB = Boolean.TRUE; } ] booleanTest = booleanTest() { return new BooleanFactor(notB, booleanTest); }
}
BooleanTest booleanTest():
{
	BooleanPrimary booleanPrimary = null;
	Boolean isB = null;
	Boolean notB = null;
	TruthValue truthValue = null;
}
{
	booleanPrimary = booleanPrimary() [ <is> { isB = Boolean.TRUE; } [ <not> {notB = Boolean.TRUE; }] truthValue = truthValue() ]
	{ return new BooleanTest(booleanPrimary, isB, notB, truthValue); }
}
BooleanPrimary booleanPrimary():
{
	Predicate predicate = null;
	SearchCondition searchCondition = null;
}
{
	LOOKAHEAD(2)
	predicate = predicate() { return new BooleanPrimary(predicate);}
	|  <left_paren> searchCondition = searchCondition() <right_paren> { return new BooleanPrimary(searchCondition); }
}
Predicate predicate():
{
	ComparisonPredicate comparisonPredicate = null;
	BetweenPredicate betweenPredicate = null;
	InPredicate inPredicate = null;
	LikePredicate likePredicate = null;
	NullPredicate nullPredicate = null;
	OverlapsPredicate overlapsPredicate = null;
}
{
	comparisonPredicate = comparisonPredicate() { return new Predicate(comparisonPredicate);}
	| betweenPredicate = betweenPredicate() { return new Predicate(betweenPredicate); }
	| inPredicate = inPredicate() { return new Predicate(inPredicate); }
	| likePredicate = likePredicate() { return new Predicate(likePredicate); }
	| nullPredicate = nullPredicate() { return new Predicate(nullPredicate); }
	| overlapsPredicate = overlapsPredicate() { return new Predicate(overlapsPredicate); }
}
ComparisonPredicate comparisonPredicate():
{
	RowValueConstructor rowValueConstructorLHS = null;
	CompOp compOp = null;
	RowValueConstructor rowValueConstructorRHS = null;
}
{
	rowValueConstructorLHS = rowValueConstructor() compOp = compOp() rowValueConstructorRHS = rowValueConstructor()
	{ return new ComparisonPredicate(rowValueConstructorLHS,compOp,rowValueConstructorRHS);}
}
RowValueConstructor rowValueConstructor():
{
	RowValueConstructorElement rowValueConstructorElement = null;
	RowValueConstructorList rowValueConstructorList = null;
}
{
	<left_paren> rowValueConstructorList = rowValueConstructorList() <right_paren> { return new RowValueConstructor(rowValueConstructorList); }
	| rowValueConstructorElement = rowValueConstructorElement() { return new RowValueConstructor(rowValueConstructorElement); }
}
RowValueConstructorList rowValueConstructorList():
{
	RowValueConstructorList rowValueConstructorList = new RowValueConstructorList();
	RowValueConstructorElement rowValueConstructorElement;
}
{
	rowValueConstructorElement = rowValueConstructorElement() { rowValueConstructorList.addRowValueConstructorElement(rowValueConstructorElement); }
	(<comma> rowValueConstructorElement = rowValueConstructorElement() { rowValueConstructorList.addRowValueConstructorElement(rowValueConstructorElement); } )*
	{ return rowValueConstructorList; } 
}
RowValueConstructorElement rowValueConstructorElement():
{
	ValueExpression valueExpression;
}
{
		<null_specification> { return new RowValueConstructorElement(Boolean.TRUE, null); }
	|	<default_specification> { return new RowValueConstructorElement(null, Boolean.TRUE); }
	|	valueExpression = valueExpression() { return new RowValueConstructorElement(valueExpression); }
}
CompOp compOp():
{}
{
		<equals_operator> { return CompOp.EQUALS_OPERATOR;}
	|   <not_equals_operator> { return CompOp.NOT_EQUALS_OPERATOR;}
	|   <less_than_operator> { return CompOp.LESS_THAN_OPERATOR;}
	|   <greater_than_operator> { return CompOp.GREATER_THAN_OPERATOR;}
	|   <less_than_or_equals_operator> { return CompOp.LESS_THAN_OR_EQUALS_OPERATOR;}
	|   <greater_than_or_equals_operator> {return CompOp.GREATER_THAN_OR_EQUALS_OPERATOR;} 
}
BetweenPredicate betweenPredicate():
{
	RowValueConstructor rowValueConstructorLHS = null;
	Boolean notB = null;
	RowValueConstructor betweenRowValueConstructor = null;
	RowValueConstructor andRowValueConstructorRHS = null;
}
{
	rowValueConstructorLHS = rowValueConstructor() [ <not> { notB = Boolean.TRUE; }] <between> betweenRowValueConstructor = rowValueConstructor() <and>  andRowValueConstructorRHS = rowValueConstructor()
	{ return new BetweenPredicate(rowValueConstructorLHS, notB, betweenRowValueConstructor, andRowValueConstructorRHS);}
}
InPredicate inPredicate():
{
	RowValueConstructor rowValueConstructorLHS = null;
	Boolean notB = null;
	InPredicateValue inPredicateValue = null;
}
{
	rowValueConstructorLHS = rowValueConstructor() [ <not> {notB = Boolean.TRUE;} ] <in> inPredicateValue = inPredicateValue()
	{ return new InPredicate(rowValueConstructorLHS, notB, inPredicateValue);}
}
InPredicateValue inPredicateValue():
{
	InValueList inValueList = null;
}
{
	<left_paren> inValueList = inValueList() <right_paren>
	{ return new InPredicateValue(inValueList); }
}
InValueList inValueList():
{
	InValueList inValueList = new InValueList();
	ValueExpression valueExpression = null;
}
{
	valueExpression = valueExpression() { inValueList.addValueExpression(valueExpression); }
	( <comma> valueExpression = valueExpression() { inValueList.addValueExpression(valueExpression); } )*
	{ return inValueList; }
}
LikePredicate likePredicate():
{
	MatchValue matchValue = null;
	Boolean notB = null;
	Pattern pattern = null;
	EscapeCharacter escapeCharacter = null;
}
{
	matchValue = matchValue() [ <not> { notB = Boolean.TRUE; }] <like> pattern = pattern() [ <escape> escapeCharacter = escapeCharacter() ]
	{ return new LikePredicate(matchValue,notB,pattern,escapeCharacter);}
}
MatchValue matchValue():
{
	CharacterValueExpression characterValueExpression = null;
}
{
	characterValueExpression = characterValueExpression()
	{return new MatchValue(characterValueExpression);}
}
Pattern pattern():
{
	CharacterValueExpression characterValueExpression = null;
}
{
	characterValueExpression = characterValueExpression()
	{return new Pattern(characterValueExpression);}
}
EscapeCharacter escapeCharacter():
{
	CharacterValueExpression characterValueExpression = null;
}
{
	characterValueExpression = characterValueExpression()
	{return new EscapeCharacter(characterValueExpression);}
}
NullPredicate nullPredicate():
{
	Boolean notB = null;
}
{
	<is> [ <not> {notB=Boolean.TRUE;}] <null_specification>
	{ return new NullPredicate(notB); }
}
OverlapsPredicate overlapsPredicate():
{
	RowValueConstructor rowValueConstructorLHS = null;
	RowValueConstructor rowValueConstructorRHS = null;
}
{
	rowValueConstructorLHS = rowValueConstructor() <overlaps> rowValueConstructorRHS =rowValueConstructor()
	{ return new OverlapsPredicate(rowValueConstructorLHS,rowValueConstructorRHS);}
}
ValueExpression valueExpression():
{
	StringValueExpression stringValueExpression = null;
}
{
	stringValueExpression = stringValueExpression() { return new ValueExpression(stringValueExpression); }
}
StringValueExpression stringValueExpression():
{
	CharacterValueExpression characterValueExpression;
}
{
	characterValueExpression = characterValueExpression() { return new StringValueExpression(characterValueExpression); }
}
CharacterValueExpression characterValueExpression():
{
	CharacterFactor characterFactor = null;
}
{
	characterFactor = characterFactor() { return new CharacterValueExpression(characterFactor); }
}
CharacterFactor characterFactor():
{
	CharacterPrimary characterPrimary;
}
{
	characterPrimary = characterPrimary() { return new CharacterFactor(characterPrimary); }
}
CharacterPrimary characterPrimary():
{
	ValueExpressionPrimary valueExpressionPrimary = null;
}
{
	valueExpressionPrimary = valueExpressionPrimary() { return new CharacterPrimary(valueExpressionPrimary); }
}
TruthValue truthValue():
{}
{
	<_true> { return TruthValue.TRUE; }
	| <_false> { return TruthValue.FALSE; }
	| <unknown> { return TruthValue.UNKNOWN; }
}
